package alloy.compiler;

import alloy.compiler.symbol.Construct;
import alloy.compiler.symbol.SymbolActivation;
import alloy.compiler.symbol.TokenGroup;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.PrimitiveIterator;

import

public class RunCompiler {
	private static final Path TEST_PATH = Path.of("example/Simple.alloy");

	public static void main(String[] args) throws IOException {
		PrimitiveIterator.OfInt iterator = AlloyScanner.codePoints(TEST_PATH).iterator();

		/* Only constructs terminate other constructs */
		Deque<Construct> stack = new ArrayDeque<>();

		/* For building constructs (ie this is the "scanner") */
		Deque<Integer> charStack = new ArrayDeque<>();
		TokenGroup lookingFor = TokenGroup.ANY;

		while(iterator.hasNext()) {
			int codePoint = iterator.nextInt();

			/* TODO actually need to create a system to build a table given some grammar rules */
			/* rows are states, columns are different tokens */
			/* a given token at a given state in the table will give the number of tokens to reduce by or signal that it should shift instead, or if its erroneous*/
			/* I think I can skip using a scanner by categorizing all characters as a type of token
			*   ie an alphabetical character or chinese character or whatever is a name_char, a + is a plus_char, etc. so no need for a token column for every unicode char
			*  */

			/* Parser: first write code to generate a terminal from a single character, ie is a name char (a letter), a left paren, right paren, separator (space, newline), etc.
Will have separate classes/enum/interface stuff for the rules themselves and the tokens generated by rules (which contain the actual instance data including line number/pos and value (ie chars and child nonterminals/terminals)
 */

			/* Mess around with this http://jsmachines.sourceforge.net/machines/lr1.html */

			/* Different grammar rule types to model:
			*   character - so I can view a single character as a token
			*   construct - so I can compose constructs
			*   end_of_file -
			*   term      - some kind of terminal thing ???
			*
			*  */

			if(charStack.isEmpty()) {
				/* Need to scan for another basic Construct (tag, name, string, bracket, number, comment, etc.) */
			} else {
				/* See if a new Construct can be formed yet, if so, see if it can combine to reduce with other Constructs to another Construct */
				charStack.push(codePoint);
			}
		}
	}
}
